<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Go Game</title>
    <style>
        .board {
            width: 570px;
            height: 570px;
            border: none;
            position: relative;
            background-color: #DDA15E;
            margin: 30px;
        }

        .line {
            position: absolute;
            background-color: #000;
        }

        .stone {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
        }

        .black {
            background-color: #000;
        }

        .white {
            background-color: #fff;
        }
    </style>
</head>
<body>
    <div class="board" id="board"></div>
    <button onclick="undo()">Undo</button>
    <button onclick="downloadSgf()">Download SGF</button>

    <script>
        var boardSize = 19;
        var cellSize = 30;
        var board = document.getElementById('board');
        var currentPlayer = 'black';
        var boardState = [];
        var lastBoardState = null;
        var undoStack = [];

        for (var i = 0; i < boardSize; i++) {
            boardState[i] = [];
            for (var j = 0; j < boardSize; j++) {
                boardState[i][j] = null;

                // Drawing the board lines
                if (j === 0) {
                    var verticalLine = document.createElement('div');
                    verticalLine.className = 'line';
                    verticalLine.style.width = '1px';
                    verticalLine.style.height = ((boardSize -1) * cellSize) + 'px';
                    verticalLine.style.left = cellSize * 0.5 + (i * cellSize) + 'px';
                    verticalLine.style.top = cellSize * 0.5 + 'px';
                    board.appendChild(verticalLine);
                }

                if (i === 0) {
                    var horizontalLine = document.createElement('div');
                    horizontalLine.className = 'line';
                    horizontalLine.style.height = '1px';
                    horizontalLine.style.width = ((boardSize -1) * cellSize) + 'px';
                    horizontalLine.style.top = cellSize * 0.5 + (j * cellSize) + 'px';
                    horizontalLine.style.left = cellSize * 0.5 + 'px';
                    board.appendChild(horizontalLine);
                }
            }
        }

        board.addEventListener('click', function(e) {
            var rect = board.getBoundingClientRect();
            var x = Math.floor((e.clientX - rect.left) / cellSize);
            var y = Math.floor((e.clientY - rect.top) / cellSize);
            placeStone(y, x, currentPlayer);
        });

        function placeStone(x, y, color) {
            if (boardState[x][y] !== null) return;

            // Clone current state for ko rule check
            var tempState = JSON.parse(JSON.stringify(boardState));

            boardState[x][y] = color;

            var captures = checkCaptures(x, y, color);
            var capturedStones = [];

            if (captures === 0 && hasLiberties(x, y, [], color) === 0) {
                // Suicide move
                boardState = tempState;
                return;
            }

            var stone = document.createElement('div');
            stone.className = 'stone ' + color;
            stone.style.top = (x * cellSize) + 'px';
            stone.style.left = (y * cellSize) + 'px';
            stone.style.width = cellSize + 'px';
            stone.style.height = cellSize + 'px';

            board.appendChild(stone);

            currentPlayer = (currentPlayer === 'black') ? 'white' : 'black';

            // Ko rule: Check if the new board state is the same as the last state
            if (lastBoardState && JSON.stringify(boardState) === JSON.stringify(lastBoardState.state)) {
                board.removeChild(stone);
                boardState = tempState;
                return;
            }

            // Add captured stones to last state
            for (var i = 0; i < captures.length; i++) {
                capturedStones.push({ x: captures[i].x, y: captures[i].y, color: captures[i].color });
            }

            // Add current state to undo stack
            lastBoardState = { state: tempState, stone: stone, capturedStones: capturedStones };
            undoStack.push(lastBoardState);
        }

        function undo() {
            if (undoStack.length === 0) return;

            // Remove last state from undo stack
            var lastState = undoStack.pop();
            boardState = JSON.parse(JSON.stringify(lastState.state));
            if (lastState.stone) {
                board.removeChild(lastState.stone);
            }

            // restore captured stones
            for (var i = 0; i < lastState.capturedStones.length; i++) {
                var stone = document.createElement('div');
                stone.className = 'stone ' + lastState.capturedStones[i].color;

                stone.style.top = (lastState.capturedStones[i].x * cellSize) + 'px';
                stone.style.left = (lastState.capturedStones[i].y * cellSize) + 'px';
                stone.style.width = cellSize + 'px';
                stone.style.height = cellSize + 'px';

                board.appendChild(stone);
                boardState[lastState.capturedStones[i].x][lastState.capturedStones[i].y] = lastState.capturedStones[i].color;
            }


            // Switch current player
            currentPlayer = (currentPlayer === 'black') ? 'white' : 'black';
        }

        function checkCaptures(x, y, color) {
            var capturedStones = [];
            var oppositeColor = (color === 'black') ? 'white' : 'black';
            var directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];

            for (var i = 0; i < directions.length; i++) {
                var newX = x + directions[i][0];
                var newY = y + directions[i][1];

                if (newX >= 0 && newX < boardSize && newY >= 0 && newY < boardSize && boardState[newX][newY] === oppositeColor) {
                    if (hasLiberties(newX, newY, [], oppositeColor) === 0) {
                        var stonesToRemove = [];
                        gatherStones(newX, newY, oppositeColor, stonesToRemove);
                        capturedStones = capturedStones.concat(stonesToRemove);
                        stonesToRemove.forEach(function(stone) {
                            removeStones(stone.x, stone.y, oppositeColor);
                        });
                    }
                }
            }

            return capturedStones;
        }

        function gatherStones(x, y, color, stonesList) {
            if (x < 0 || x >= boardSize || y < 0 || y >= boardSize) return;
            if (boardState[x][y] !== color) return;
            if (stonesList.some(function(stone) { return stone.x === x && stone.y === y; })) return;

            stonesList.push({ x: x, y: y, color: color });

            var directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            for (var i = 0; i < directions.length; i++) {
                var dir = directions[i];
                gatherStones(x + dir[0], y + dir[1], color, stonesList);
            }
        }

        function hasLiberties(x, y, visited, color) {
            if (x < 0 || x >= boardSize || y < 0 || y >= boardSize) return 0;

            if (visited.some(function(point) { return point[0] === x && point[1] === y; })) return 0;

            if (boardState[x][y] === null) return 1;

            if (boardState[x][y] !== color) return 0;

            visited.push([x, y]);

            return hasLiberties(x - 1, y, visited, color) ||
                   hasLiberties(x + 1, y, visited, color) ||
                   hasLiberties(x, y - 1, visited, color) ||
                   hasLiberties(x, y + 1, visited, color);
        }

        function removeStones(x, y, color) {
            boardState[x][y] = null;

            var stoneElements = board.querySelectorAll('.stone.' + color);
            for (var i = 0; i < stoneElements.length; i++) {
                if (stoneElements[i].style.top === (x * cellSize) + 'px' && stoneElements[i].style.left === (y * cellSize) + 'px') {
                    board.removeChild(stoneElements[i]);
                    break;
                }
            }
        }

        function exportSgf() {
            var sgf = '(;FF[4]GM[1]SZ[' + boardSize + ']PB[Black]PW[White]KM[7.5]';

            for (var i = 0; i < undoStack.length; i++) {
                var state = undoStack[i];
                if (state.stone) {
                    var x = state.stone.style.top.slice(0, -2) / cellSize;
                    var y = state.stone.style.left.slice(0, -2) / cellSize;
                    var color = state.stone.classList.contains('black') ? 'B' : 'W';
                    sgf += ';' + color + '[' + (18 - String.fromCharCode(97 + y)) + String.fromCharCode(97 + (boardSize - x - 1)) + ']';
                }
            }

            sgf += ')';

            return sgf;
        }

        function downloadSgf() {
            var sgf = exportSgf();
            var blob = new Blob([sgf], { type: 'text/plain' });
            var url = URL.createObjectURL(blob);
            var a = document.createElement('a');
            a.href = url;
            a.download = 'game.sgf';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
